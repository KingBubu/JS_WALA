<h1>Description of the Normalization</h1>

<h2>JavaScript Normal Form</h2>

<p>A program in JavaScript Normal Form (JSNF) obeys the following grammar:</p>

<pre><code>Program ::= (function(__global) { Decl? Stmt* })(this);

Decl    ::= var x1, x2, ..., xn;

Stmt    ::= x = (function f(y1, ..., yn) { Decl? Stmt+ });
         |  x = LITERAL;
         |  x = null;
         |  x = this;
         |  x = [ y1, ..., yn ];
         |  x = { Prop* };
         |  x = y;
         |  x = y[z];
         |  x[y] = z;
         |  x = delete y;
         |  x = delete y[z];
         |  x = UNOP y;
         |  x = y CREMENT;
         |  x = y BINOP z;
         |  x = f(y1, ..., yn);
         |  x = z[f](y1, ..., yn);
         |  x = new f(y1, ..., yn);
         |  return x;
         |  return;
         |  break l;
         |  throw x;
         |  ;
         |  l: Stmt
         |  if(x) { Stmt+ } else { Stmt+ }
         |  while(x) { Stmt+ }
         |  for(x in y) { Stmt+ }
         |  try { Stmt+ } catch(x) { Stmt+ }
         |  try { Stmt+ } finally { Stmt+ }

Prop    ::= STRING : y
         |  get p() { Stmt+ }
         |  set p(x) { Stmt+ }
</code></pre>

<p>Here, <code>x</code>, <code>y</code>, <code>z</code>, <code>f</code>, <code>p</code>, <code>l</code> and variants are names. The terminal <code>LITERAL</code> stands for a string, number, boolean or regular expression literal.
<code>STRING</code> is a string literal; <code>UNOP</code> is a unary operator; <code>CREMENT</code> is <code>++</code> or <code>--</code>; <code>BINOP</code> is a binary operator.</p>

<p>Names always refer to local variables, whereas references to global variables are rewritten into appropriate property reads or writes on <code>__global</code>.
If the normalizer is passed the <code>reference_errors</code> option, reads of global variables will further be rewritten to throw a <code>ReferenceError</code> exception if the variable in question has not been declared or defined.
The sole exception to this are direct calls to <code>eval</code>, where the callee expression <code>eval</code> may be a reference to a global variable.
This is necessary to preserve semantics.</p>

<p>The translation to normal form introduces (lots of) temporary variables named <code>tmp0</code>, <code>tmp1</code> and so on. The normalizer does not check for name clashes with existing variables, although it undoubtedly should.</p>

<p>Note that <code>for</code> and <code>do</code> loops are desugared into <code>while</code> loops, <code>continue</code> statements are converted into <code>break</code> statements. This sometimes results in (moderate amounts of) code duplication. All <code>break</code> statements in the normalized program have an explicit target label.</p>

<p>If the normalizer is passed the <code>unfold_ifs</code> option, <code>if</code> statements are further simplified so that at most one of their branches is non-trivial, i.e., contains a non-empty statement.</p>

<p>If the normalizer is passed the <code>unify_ret</code> option, every function only contains one single <code>return</code> statement at the very end of the function; all other <code>return</code> statements are converted into assignments to a result variable and a following <code>break</code> statement. The normalized program will not contain empty return statements of the form <code>return;</code>.</p>

<h2>Position information</h2>

<p>If the original AST has position information, then so does the normalized AST, with every normarized AST node having the same position as the node it originated from.</p>

<p>However, we do not use the Esprima position annotations, which somewhat awkwardly distribute position information across several different properties.
Instead, the position information for node <code>nd</code> is stored in <code>nd.attr.pos</code>, and is represented as an object constructed by function <code>Position</code> (defined in <code>lib/position.js</code>), which has properties <code>url</code>, <code>start_line</code>, <code>start_offset</code>, <code>end_line</code> and <code>end_offset</code>.
The <code>url</code> property stores the URL of the enclosing script, <code>start_line</code> and <code>end_line</code> correspond to Esprima's <code>loc.start.line</code> and <code>loc.end.line</code>, whereas <code>start_offset</code> and <code>end_offset</code> are character offsets from the beginning of the file, corresponding to <code>range[0]</code> and <code>range[1]</code> in Esprima.</p>

<p>Esprima ASTs do not usually store a program's URL.
When the normalizer is passed an AST, it first checks whether the root node has the (non-standard) property <code>url</code>, and if so takes this to be the program's URL.
Otherwise, it checks whether the <code>options</code> object (see above) has a <code>url</code> property.
If neither is the case, the URL defaults to <code>&lt;UNKNOWN&gt;</code>.</p>
